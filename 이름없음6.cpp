이진탐색


무리 중에서 원하는 값이 있는지 탐색


절반씩 줄여나가면서 찾는 것
 

정렬된 데이터에서 찾는 것 
 
시작점 
끝지점
중간지점

a[5] = {1,2,3,4,5};

1 2 3 4 5 

0   2	4


5 4 4 

6


찾는 값이 더 클 떄는 시작값이 중간 +1번으로 넘어옴

시작 3
중간 3 
끝 4
 
중간지점 값이 찾는값과 비교하여 같으면 찾음 


s 0
m (s+e)/2;
e n-1

while(s<=e){
	if(A[m] == search){
		printf("찾음");
	}
	else if(A[m] < search){
		s = m+1;
	}
	else if(A[m] > search){
		e = m-1;
		
	}
	m = (s+e)/2;
}


입력범위가 1~n

최댓값 => 0으로 초기화
 
최솟값은 -> n+1;


A = 65
Z = 90
a = 97
z = 122
0 = 48 - 48
9 = 57
공백 = 32

문자값을 그대로 정수로 표현하는 방법

a 123321
 
 a[1] = '2'
 
 a[1] - 48
 
 
 알고리즘 활용해보면서
 
 문자열 <-> 정수 변환
 구조체
 사용자 정의 함수
 재귀함수
 포인터
 동적할당
 연결리스트
 자료구조 큐
 자료구조 스택
 6 ~ 8
 
반바뀔 수 있음 c++
 기본문법 -> 자료구조(STL) => 반바뀜 대회알고리즘 -> 죽어라 문제풀기
 
 
